/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.ractoc.fs.templates.editor.entity;

import com.ractoc.fs.es.EntityComponent;
import com.ractoc.fs.parsers.entitytemplate.ComponentParser;
import com.ractoc.fs.parsers.entitytemplate.ComponentParsersCache;
import com.ractoc.fs.parsers.entitytemplate.annotation.Template;
import com.ractoc.fs.templates.editor.EtplTopComponent;
import com.ractoc.fs.templates.editor.FieldModifiedListener;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Set;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JTextField;
import org.scannotation.AnnotationDB;

/**
 *
 * @author ractoc
 */
public class ComponentEditorPanel extends javax.swing.JPanel implements ActionListener {

    private String componentClassName;
    private Class<? extends EntityComponent> componentClass;
    private URLClassLoader loader;
    private JComboBox<String> componentCombo;
    private EtplTopComponent topComponent;
    private EntityComponent entityComponent;
    private ComponentParsersCache componentParsers = new ComponentParsersCache();
    private static final String TEMPLATE_CLASS_NAME = Template.class.getName();
    private EntityTemplateEditorPanel listener;
    private boolean newComponent;

    /**
     * Creates new form ComponentEditorPanel
     */
    public ComponentEditorPanel(EtplTopComponent topComponent) throws IOException {
        this.topComponent = topComponent;
        this.loader = topComponent.getLoader();
        initComponents();
        componentParsers.setClassLoader(loader);
        setComponentContainers();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        jPanel1 = new javax.swing.JPanel();
        componentKeyContainer = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        componentValueContainer = new javax.swing.JPanel();

        setLayout(new java.awt.BorderLayout());

        jSplitPane1.setDividerLocation(150);

        jPanel1.setLayout(new java.awt.BorderLayout());

        javax.swing.GroupLayout componentKeyContainerLayout = new javax.swing.GroupLayout(componentKeyContainer);
        componentKeyContainer.setLayout(componentKeyContainerLayout);
        componentKeyContainerLayout.setHorizontalGroup(
            componentKeyContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 150, Short.MAX_VALUE)
        );
        componentKeyContainerLayout.setVerticalGroup(
            componentKeyContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        jPanel1.add(componentKeyContainer, java.awt.BorderLayout.NORTH);

        jSplitPane1.setLeftComponent(jPanel1);

        jPanel2.setLayout(new java.awt.BorderLayout());

        javax.swing.GroupLayout componentValueContainerLayout = new javax.swing.GroupLayout(componentValueContainer);
        componentValueContainer.setLayout(componentValueContainerLayout);
        componentValueContainerLayout.setHorizontalGroup(
            componentValueContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 244, Short.MAX_VALUE)
        );
        componentValueContainerLayout.setVerticalGroup(
            componentValueContainerLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        jPanel2.add(componentValueContainer, java.awt.BorderLayout.NORTH);

        jSplitPane1.setRightComponent(jPanel2);

        add(jSplitPane1, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel componentKeyContainer;
    private javax.swing.JPanel componentValueContainer;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JSplitPane jSplitPane1;
    // End of variables declaration//GEN-END:variables

    private void setComponentContainers() {
        componentKeyContainer.setLayout(new GridLayout(0, 1));
        componentValueContainer.setLayout(new GridLayout(0, 1));
    }

    public void createEditorForOldComponent(EntityComponent component) {
        newComponent = false;
        this.entityComponent = component;
        this.componentClass = component.getClass();
        this.componentClassName = component.getClass().getName();
        createEditorForComponent();
    }

    private void createEditorForComponent() {
        clearComponentEditor();
        createEntityComponentEditor();
        repopulateComponentEditor();
    }

    public void createEditorForNewComponent() {
        newComponent = true;
        createEntityComponentEditor();
        repopulateComponentEditor();
    }

    public void clearComponentEditor() {
        componentKeyContainer.removeAll();
        componentValueContainer.removeAll();
    }

    public void repopulateComponentEditor() {
        componentKeyContainer.invalidate();
        componentValueContainer.validate();
    }

    private void createEntityComponentEditor() {
        try {
            createClassNameFields();
            addParameterFields();
        } catch (Exception ex) {
            topComponent.displayErrorMessage("Unable to create Component Editor.");
        }
    }

    private void createClassNameFields() throws IOException {
        JLabel key = createClassNameKey();
        createClassNameValue(key);
    }

    private JLabel createClassNameKey() {
        JLabel key = new JLabel("Entity Component");
        key.setPreferredSize(new Dimension(150, 28));
        return key;
    }

    private void createClassNameValue(JLabel key) throws IOException {
        if (newComponent) {
            createComponentTypeDropDown();
            addComponentParameter(key, componentCombo);
        } else {
            JLabel value = new JLabel(componentClassName);
            addComponentParameter(key, value);
        }
    }

    private void createComponentTypeDropDown() throws IOException {
        componentCombo = new JComboBox(readTemplateComponentsFromClasspath());
        componentCombo.setName("componentTypeList");
        componentCombo.setEditable(false);
        componentCombo.setSelectedItem(componentClassName);
        componentCombo.addActionListener(this);
    }

    public void addComponentParameter(JLabel key, Component value) {

        componentKeyContainer.add(key);
        componentValueContainer.add(value);
    }

    private String[] readTemplateComponentsFromClasspath() throws IOException {
        AnnotationDB db = new AnnotationDB();
        URL[] urls = getURLsFromClassPath();
        db.scanArchives(urls);
        Set<String> componentClasses =
                db.getAnnotationIndex().get(TEMPLATE_CLASS_NAME);
        return componentClasses.toArray(new String[]{});
    }

    private URL[] getURLsFromClassPath() {
        return loader.getURLs();
    }

    private void addParameterFields() throws Exception {
        Method[] methods = componentClass.getDeclaredMethods();
        for (Method method : methods) {
            addParameterFieldFromMethod(method);
        }
    }

    private void addParameterFieldFromMethod(Method method) throws Exception {
        if (method.getName().startsWith("get")) {
            addParameterFieldFromGetter(method);
        }
    }

    private void addParameterFieldFromGetter(Method method) throws Exception {
        JLabel key = createParameterKey(method);
        JTextField value = createParameterValue(method);
        addComponentParameter(key, value);
    }

    private JLabel createParameterKey(Method method) {
        String parKey = getParameterNameFromMethodName(method);
        parKey = parKey.substring(0, 1).toLowerCase() + parKey.substring(1);
        JLabel key = new JLabel(parKey);
        key.setPreferredSize(new Dimension(10, 28));
        return key;
    }

    private String getParameterNameFromMethodName(Method method) {
        String methodName = method.getName().substring(3);
        methodName = methodName.substring(0,1).toLowerCase() + methodName.substring(1);
        return methodName;
    }

    private JTextField createParameterValue(Method method) throws Exception {
        JTextField value = new JTextField();
        if (!newComponent) {
            value.addKeyListener(new FieldModifiedListener(listener));
            value.setText(method.invoke(entityComponent).toString());
        }
        value.setName(getParameterNameFromMethodName(method));
        value.setPreferredSize(new Dimension(10, 28));
        return value;
    }

    @Override
    public void actionPerformed(ActionEvent event) {
        entityComponent = null;
        getSelectedComponentClass();
        createEditorForComponent();
    }

    private void getSelectedComponentClass() {
        try {
            componentClassName = (String) componentCombo.getSelectedItem();
            if (componentClassName != null) {
                componentClass = (Class<? extends EntityComponent>) loader.loadClass(componentClassName);
            } else {
                clearComponentEditor();
                createClassNameFields();
            }
        } catch (IOException ex) {
            topComponent.displayErrorMessage("Unable to load the list of possible components");
        } catch (ClassNotFoundException ex) {
            topComponent.displayErrorMessage("Unable to load component " + componentClassName);
        }
    }

    public Class<? extends EntityComponent> getComponentClass() {
        return componentClass;
    }

    public EntityComponent getEntityComponent() {
        entityComponent = null;
        if (componentClassName != null) {
            try {
                componentClass = (Class<? extends EntityComponent>) loader.loadClass(componentClassName);
                entityComponent = null;
                ComponentParser componentParser = componentParsers.getParserForComponentType(componentClass);
                componentParser.clear();
                for (Component inputComponent : componentValueContainer.getComponents()) {
                    if (inputComponent instanceof JTextField) {
                        componentParser.setProperty(inputComponent.getName(), ((JTextField) inputComponent).getText());
                    }
                }
                entityComponent = componentParser.getParsedComponent();
            } catch (ClassNotFoundException ex) {
                topComponent.displayErrorMessage("Unable to load component " + componentClassName);
            }
        }
        return entityComponent;
    }

    void setPersistComponentListener(EntityTemplateEditorPanel listener) {
        this.listener = listener;
    }
}
